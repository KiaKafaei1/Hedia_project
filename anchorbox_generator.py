# -*- coding: utf-8 -*-
"""anchorbox_generator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UyJUFUeV9iiJwSG9xuV9iCVNLdU0VcJk
"""

# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aXtcmr3xTYcCMODQbHOEoOrcImcbPq4Y
"""

import numpy as np
import cv2
import math

def Anchorbox_generator(bbox0=[],label=[], anc_pos_iou_thresh=0.7, anc_neg_iou_thresh = 0.3, anc_pos_ratio=0.5, anc_n_sample=256):
    # Define the number of anchor boxes at each anchor point
    ratios = [0.5, 1, 2]
    anchor_scales = [8, 16, 32]

    anchor_base = np.zeros((len(ratios) * len(anchor_scales), 4), dtype=np.float32)

    # The output of the feature extraction should have a feature map size of (800//16)
    sub_sample = 16

    # Fill out the coordinates for each anchor scale and ratios
    ctr_y = sub_sample / 2.
    ctr_x = sub_sample / 2.

    #print(800//16)

    #print(ctr_y, ctr_x)
    for i in range(len(ratios)):
      for j in range(len(anchor_scales)):
        h = sub_sample * anchor_scales[j] * np.sqrt(ratios[i])
        w = sub_sample * anchor_scales[j] * np.sqrt(1./ ratios[i])

        index = i * len(anchor_scales) + j

        anchor_base[index, 0] = ctr_y - h / 2.
        anchor_base[index, 1] = ctr_x - w / 2.
        anchor_base[index, 2] = ctr_y + h / 2.
        anchor_base[index, 3] = ctr_x + w / 2.
    #print(anchor_base)

    # Centers for each feature map pixel
    fe_size = (800//16)
    ctr_x = np.arange(16, (fe_size+1) * 16, 16)
    ctr_y = np.arange(16, (fe_size+1) * 16, 16)

    # Generate center for each location
    index = 0
    ctr = np.zeros((len(ctr_x)*len(ctr_y),2))
    for x in range(len(ctr_x)):
      for y in range(len(ctr_y)):
        ctr[index, 1] = ctr_x[x] - 8
        ctr[index, 0] = ctr_y[y] - 8
        index += 1

    anchors = np.zeros(((fe_size * fe_size * 9), 4))
    index = 0
    for c in ctr:
      ctr_y, ctr_x = c
      for i in range(len(ratios)):
        for j in range(len(anchor_scales)):
          h = sub_sample * anchor_scales[j] * np.sqrt(ratios[i])
          w = sub_sample * anchor_scales[j] * np.sqrt(1./ ratios[i]) 
          anchors[index, 0] = ctr_y - h / 2.
          anchors[index, 1] = ctr_x - w / 2.
          anchors[index, 2] = ctr_y + h / 2.
          anchors[index, 3] = ctr_x + w / 2.
          index += 1
    if isinstance(label, list):
      return anchors

    else: 
      # Assign ground truth bounding box and label
      bbox = bbox0 # [y1, x1, y2, x2] format
      labels = label

      # Find valid anchor boxes
      index_inside = np.where(
              (anchors[:, 0] >= 0) &
              (anchors[:, 1] >= 0) &
              (anchors[:, 2] <= 800) &
              (anchors[:, 3] <= 800)
          )[0]
      valid_anchor_boxes = anchors[index_inside]
      #print(valid_anchor_boxes.shape)

      # Create empty label array
      label = np.empty((len(index_inside), ), dtype=np.int32)
      label.fill(-1)
      #print(label.shape)

      # Calculate the IoU
      ious = np.empty((len(valid_anchor_boxes), len(bbox[:,1])), dtype=np.float32)
      ious.fill(0)
      for num1, i in enumerate(valid_anchor_boxes):
          ya1, xa1, ya2, xa2 = i  
          anchor_area = (ya2 - ya1) * (xa2 - xa1)
          for num2, j in enumerate(bbox):
              yb1, xb1, yb2, xb2 = j
              box_area = (yb2- yb1) * (xb2 - xb1)        
              inter_x1 = max([xb1, xa1])
              inter_y1 = max([yb1, ya1])
              inter_x2 = min([xb2, xa2])
              inter_y2 = min([yb2, ya2])        
              if (inter_x1 < inter_x2) and (inter_y1 < inter_y2):
                  iter_area = (inter_y2 - inter_y1) *(inter_x2 - inter_x1)
                  iou = iter_area /(anchor_area+ box_area - iter_area)            
              else:
                  iou = 0.        
              ious[num1, num2] = iou
      #print(ious.shape)

      # Find the highest IoU for each ground truth box and corresponding anchor box
      gt_argmax_ious = ious.argmax(axis=0)
      #print(gt_argmax_ious)
      gt_max_ious = ious[gt_argmax_ious, np.arange(ious.shape[1])]
      #print(gt_max_ious)

      # Find the highest IoU for each anchor box and its corresponding ground truth box
      argmax_ious = ious.argmax(axis=1)
      #print(argmax_ious.shape)
      #print(argmax_ious)
      max_ious = ious[np.arange(len(index_inside)), argmax_ious]
      #print(max_ious)
      gt_argmax_ious = np.where(ious == gt_max_ious)[0]
      #print(gt_argmax_ious)

      # Set the threshold values for the IoU
      anc_pos_iou_thresh  = anc_pos_iou_thresh
      neg_iou_threshold = anc_neg_iou_thresh

      # Assign negative label (0) to anchor boxes that are under the set negative threshhold
      label[max_ious < neg_iou_threshold] = 0

      # Assign positive label (1) to all the anchor boxes which have highest IoU overlap with a ground truth box
      label[gt_argmax_ious] = 1

      # Assign positive label (1) to all the anchor boxes which have max_iou greater than positive threshold
      label[max_ious >= anc_pos_iou_thresh] = 1 

      # Set sample values
      anc_pos_ratio = anc_pos_ratio
      anc_n_sample = anc_n_sample

      # Total positive samples and negative samples
      n_pos = anc_pos_ratio * anc_n_sample
      n_pos = math.floor(n_pos)
      n_neg = anc_n_sample * np.sum(label == 1)
      n_neg = math.floor(n_neg)

      # Sample positive samples
      pos_index = np.where(label == 1)[0]
      if len(pos_index) > n_pos:
        disable_index = np.random.choice(pos_index, size=(len(pos_index) - n_pos), replace=False)
        label[disable_index] = -1

      # Sample negative samples
      neg_index = np.where(label == 0)[0]
      if len(neg_index) > n_neg:
        disable_index = np.random.choice(neg_index, size=(len(neg_index) - n_neg), replace = False)
        label[disable_index] = -1

      # For each anchor box, find the groundtruth object which has max IoU
      max_iou_bbox = bbox[argmax_ious]

      # Convert [y1, x1, y2, x2] format to [t_{x}, t_{y}, t_{w}, t_{h}] format
      height = valid_anchor_boxes[:, 2] - valid_anchor_boxes[:, 0]
      width = valid_anchor_boxes[:, 3] - valid_anchor_boxes[:, 1]
      ctr_y = valid_anchor_boxes[:, 0] + 0.5 * height
      ctr_x = valid_anchor_boxes[:, 1] + 0.5 * width

      base_height = max_iou_bbox[:, 2] - max_iou_bbox[:, 0]
      base_width = max_iou_bbox[:, 3] - max_iou_bbox[:, 1]
      base_ctr_y = max_iou_bbox[:, 0] + 0.5 * base_height
      base_ctr_x = max_iou_bbox[:, 1] + 0.5 * base_width

      # Find the anchor locations
      eps = np.finfo(height.dtype).eps
      height = np.maximum(height, eps)
      width = np.maximum(width, eps)
      dy = (base_ctr_y - ctr_y) / height
      dx = (base_ctr_x - ctr_x) / width
      dh = np.log(base_height / height)
      dw = np.log(base_width / width)
      anchor_locs = np.vstack((dy, dx, dh, dw)).transpose()
      #print(anchor_locs)

      # Get final labels
      anchor_labels = np.empty((len(anchors),), dtype=label.dtype)
      anchor_labels.fill(-1)
      anchor_labels[index_inside] = label
      #print(np.shape(anchor_labels))

      # Get final locations
      anchor_locations = np.empty((len(anchors),) + anchors.shape[1:], dtype=anchor_locs.dtype)
      anchor_locations.fill(0)
      anchor_locations[index_inside, :] = anchor_locs
      #print(np.shape(anchor_locations))

      return anchor_labels, anchor_locations, anchors